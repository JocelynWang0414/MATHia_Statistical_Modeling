# -*- coding: utf-8 -*-
"""Week_6_Detectors_vs_Teacher_Help.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cYO8Hh1V5A-O5ssYl6TMRGDk4LoF_ZH9

# Preprocess dataframe
"""

import pandas as pd
from datetime import datetime
import google.colab.drive
google.colab.drive.mount('/content/drive')
original_df = pd.read_csv("/content/drive/MyDrive/Updated_LiveLab.csv")

"""# Reset Dataframe"""

# Sampling relevant columns
selected_columns = ['Anon Student Id', 'Session Id', 'Time', 'Problem Name', 'Step Name', 'Help Level', 'Outcome', 'CF (Skill New p-Known)', 'helpedTransaction']
df = original_df[selected_columns]
df.columns.to_list()
print(len(df))
# all_session_id = df['Session Id'].unique().tolist()
# all_student_id = df['Anon Student Id'].unique().tolist()
# print(df['Session Id'].value_counts())
print(df['helpedTransaction'].value_counts())

"""# Randomly sample one student one id"""

# Sampling one student and one id
student_id ='s44'
session_id ='egqyi9-dzg6pvmpp8qgpyzxd_vi:1669793394692'
print(len(df[df['Anon Student Id'] == student_id]))
print(df[df['Anon Student Id'] == student_id]['Session Id'].value_counts())

"""# Sample rows where helpedtransaction == true"""

df_where_help_is_true = df[df['helpedTransaction'] == True]
print(df_where_help_is_true['Anon Student Id'].unique().tolist())
print(df_where_help_is_true['Session Id'].unique().tolist())
print(len(df_where_help_is_true))
pairs = []
for student_id in df_where_help_is_true['Anon Student Id'].unique().tolist():
  for session_id in df_where_help_is_true[df_where_help_is_true['Anon Student Id'] == student_id]['Session Id'].unique().tolist():
    pairs.append((student_id, session_id))
print(pairs)

"""# Load auxiliary functions"""

def is_deliberate_function(last_action, last_transaction, this_transaction):
    seconds_since_last_action = int((datetime.strptime(this_transaction['Time'], "%Y-%m-%d %H:%M:%S") - datetime.strptime(last_transaction['Time'], "%Y-%m-%d %H:%M:%S")).total_seconds())
    if last_action == 'error': return seconds_since_last_action > config['error_threshold']
    elif last_action == 'initial_hint' or 'hint_level_change': return seconds_since_last_action > config['hint_threshold'] # improvement: from calculated hint_threshold to pre-defined hint threshold
    return seconds_since_last_action > config['new_step_threshold']

def seen_all_hint_levels_function(this_transaction, four_leveled_steps):
    has_fourth_level_hint =  (this_transaction['Problem Name'], this_transaction['Step Name']) in four_leveled_steps
    return False if (this_transaction['Help Level'] < 3 or (has_fourth_level_hint and this_transaction['Help Level'] < 4)) else True

def sense_of_what_to_do_function(this_transaction):

    # Jocelyn: need the [p_know] for all skills in rawSkills to be above the senseOfWhatToDoThreshold
    return this_transaction['CF (Skill New p-Known)'] > config['sense_of_what_to_do_threshold']

def is_low_skill_step_some_function(this_transaction):
    return this_transaction['CF (Skill New p-Known)'] <= config['familiarity_threshold']

def is_familiar_function(this_transaction):
    return this_transaction['CF (Skill New p-Known)'] > config['familiarity_threshold']

def evaluate_action(last_transaction, this_transaction, four_leveled_steps):
    last_action = last_transaction['Outcome'].lower() # hint or others
    is_correct = (this_transaction['Outcome'].lower() == "ok")
    last_action_is_error, last_action_is_hint, last_action_unclear_fix = (last_action == "error"), (last_action == 'initial_hint' or 'hint_level_change'), (last_action == 'jit')

    seen_all_hint_levels = seen_all_hint_levels_function(this_transaction, four_leveled_steps)
    is_deliberate = is_deliberate_function(last_action, last_transaction, this_transaction)

    # BKT based parameters
    sense_of_what_to_do = sense_of_what_to_do_function(this_transaction)
    is_low_skill_step_some = is_low_skill_step_some_function(this_transaction)
    is_familiar = is_familiar_function(this_transaction)

    if this_transaction['Outcome'].lower() == "hint":
        print("isHint")
        if is_deliberate:
            print("isDeliberate")
            if is_low_skill_step_some and not last_action_is_error:
                return "not acceptable/asked hint on low skill step"
            else:
                if not seen_all_hint_levels and (not is_familiar or (last_action_is_error and last_action_unclear_fix) or last_action_is_hint):
                    return "preferred/ask hint"
                elif is_familiar and not sense_of_what_to_do or last_action_is_hint:
                    return "acceptable/ask hint"
                else:
                    return "hint abuse"
        else:
            print("not deliberate")
            return "hint abuse"

    else:
        if is_low_skill_step_some and not last_action_is_error:
            return "preferred/try step on low skill step"
        else:
            if is_deliberate:
                if (is_familiar and not (last_action_is_error and last_action_unclear_fix)) or (
                        last_action_is_hint):
                    return "preferred/try step"
                elif seen_all_hint_levels and not (last_action_is_error and last_action_unclear_fix):
                    return "preferred/try step"
                elif is_correct:
                    return "acceptable/try step"
                elif seen_all_hint_levels:
                    if last_action_is_error and last_action_unclear_fix:
                        return "ask teacher for help"
                else:
                    return "hint avoidance"
            else:
                return "not deliberate"

def is_not_deliberate(help_model_output): return help_model_output == "not deliberate"
def is_gaming(help_model_output): return False
def is_abusing_hints(help_model_output): return help_model_output == "hint abuse"

# Run this code to know the maximum hint help level of each problem & associated steps from this session
def get_four_leveled_steps(df):
  four_leveled_steps = set()
  for i in range(len(df)):

    if df.iloc[i]['Help Level'] == 4:
      if (df.iloc[i]['Problem Name'], df.iloc[i]['Step Name']) not in four_leveled_steps:
        prob_step_tuple = (df.iloc[i]['Problem Name'], df.iloc[i]['Step Name'])
        four_leveled_steps.add(prob_step_tuple)
  #print(four_leveled_steps)
  #print(f"{len(four_leveled_steps)} problem steps are of level 4.")
  return four_leveled_steps

"""# Main function calculating status

"""

# Function to calculate the "System Misuse" status based on conditions
def calculate_status(df, window_size, threshold, variable_name):
    status, window = [False] * window_size, []

    if variable_name == "system_misuse":
      print(f'Working on {variable_name}:')
      for i in range(window_size - 1, len(df) - 1):
          outcome = df['Outcome'].iloc[i]  # mostly OK, ERROR, INITIAL_HINT, JIT, HINT_LEVEL_CHANGE
          four_leveled_steps = get_four_leveled_steps(df)
          model_output = evaluate_action(df.iloc[i - 1], df.iloc[i], four_leveled_steps)
          # Add to attempt window based on is gaming, is abusing hints, and is not deliberate
          attemptCorrect = 1 if is_gaming(model_output) or is_abusing_hints(model_output) or is_not_deliberate(model_output) else 0
          window.append(attemptCorrect)
          # Check length fixed
          if len(window) == window_size: window.pop(0)
          # System_misuse window detection logic
          status.append(True) if sum(window) >= threshold else status.append(False)

    if variable_name == "students_doing_well":
      print(f'Working on {variable_name}:')
      for i in range(window_size - 1, len(df) - 1):
          # Add to attempt window based on action correct
          attemptCorrect = 1 if df['Outcome'].iloc[i].lower() == "ok" else 0
          window.append(attemptCorrect)
          # Check length fixed
          if len(window) == window_size: window.pop(0)
          # Students_doing_well detection logic
          status.append(True) if sum(window) >= threshold else status.append(False)

    return status

config = {}
config['error_threshold'] = 2
config['new_step_threshold'] = 1
config['sense_of_what_to_do_threshold'] = 0.6
config['familiarity_threshold'] = 0.4
config['window_size'] = 10
config['hint_threshold'] = 6

config['system_misuse_threshold'] = 8 # system_misuse frequency = 20~40% when choosing 8; the higher the threshold, the lower system misuse
config['students_doing_well_threshold'] = 7 # students_doing_well frequency = 10~50% when choosing 7

def get_statistics(status, variable_name):
  # print('Check if the first 9 outputs are all False: ', not (True in status[:9]))
  # print('First 20 outputs are ', status[:20], '...')
  t, f = 0, 0
  for i in range(len(status)):
    if status[i]: t+=1
    else: f +=1
  # print(f'True: {t} results out of {len(status)}')
  # print(f'False: {f} results out of {len(status)}')
  rate = round(t/len(status)*100, 2)
  return f'{variable_name} rate = {rate}%', rate

# system_misuse_status = calculate_status(df, config['window_size'], config['system_misuse_threshold'], "system_misuse")
# print(get_statistics(system_misuse_status, "system_misuse"))

# students_doing_well_status = calculate_status(df, config['window_size'], config['students_doing_well_threshold'], "students_doing_well")
# print(get_statistics(students_doing_well_status, "students_doing_well"))

i = 0
get_position = 300
misuse_rate, doing_well_rate, num_helped = [], [], []
for student_id, session_id in pairs:
  if i == 100: break
  df = original_df[selected_columns]
  df = df[df['Anon Student Id'] == student_id]
  df = df[df['Session Id'] == session_id]
  print(df['helpedTransaction'].value_counts())
  num_helped.append((df['helpedTransaction'] == True).sum())
  print(num_helped[-1], student_id, session_id)

  system_misuse_status = calculate_status(df, config['window_size'], config['system_misuse_threshold'], "system_misuse")
  print(get_statistics(system_misuse_status, "system_misuse")[0])
  misuse_rate.append(get_statistics(system_misuse_status, "system_misuse")[1])

  students_doing_well_status = calculate_status(df, config['window_size'], config['students_doing_well_threshold'], "students_doing_well")
  print(get_statistics(students_doing_well_status, "students_doing_well")[0])
  doing_well_rate.append(get_statistics(students_doing_well_status, "students_doing_well")[1])
  i+=1

import matplotlib.pyplot as plt
import numpy as np
plt.scatter(num_helped[:-1], misuse_rate, color='blue', marker='o', s=100, alpha=0.5)
plt.xlabel('Number of times helped')
plt.ylabel('System Misuse Rate')
plt.show()
plt.scatter(num_helped[:-1], doing_well_rate, color='red', marker='o', s=100, alpha=0.5)
plt.xlabel('Number of times helped')
plt.ylabel('Students Doing Well Rate')
plt.show()

"""# Correlation between system_misuse and marked help

# Obtain file and correlational analysis
"""

i = 0
get_position = 304
misuse_rate, doing_well_rate, num_helped = [], [], []
for student_id, session_id in pairs[get_position:get_position+1]:
  if i == 100: break
  df = original_df[selected_columns]
  df = df[df['Anon Student Id'] == student_id]
  df = df[df['Session Id'] == session_id]
  print(df['helpedTransaction'].value_counts())
  num_helped.append((df['helpedTransaction'] == True).sum())
  print(num_helped[-1], student_id, session_id)

  system_misuse_status = calculate_status(df, config['window_size'], config['system_misuse_threshold'], "system_misuse")
  print(get_statistics(system_misuse_status, "system_misuse")[0])
  misuse_rate.append(get_statistics(system_misuse_status, "system_misuse")[1])

  students_doing_well_status = calculate_status(df, config['window_size'], config['students_doing_well_threshold'], "students_doing_well")
  print(get_statistics(students_doing_well_status, "students_doing_well")[0])
  doing_well_rate.append(get_statistics(students_doing_well_status, "students_doing_well")[1])
  i+=1

df['system_misuse_status'] = system_misuse_status
df['students_doing_well_status'] = students_doing_well_status
output_file_path = 'new.csv'
df.to_csv(output_file_path, index=False)
output_file_path  # Return the path to the new file

df = pd.read_csv(output_file_path)
print(len(df))

helped_transaction_is_true = []
for i in range(len(df)):
  if df.iloc[i]['helpedTransaction'] == True:
    helped_transaction_is_true.append(i)
helped_transaction_is_true

def getWindow(index_of_true_help, window_size):
  print(f'index_of_true_help = {index_of_true_help}')
  num_misuse, num_doing_well, num_helped = 0,0,0
  for i in range(max(0, index_of_true_help-window_size//2), min(len(df), index_of_true_help+window_size//2)):
    if
    if df.iloc[i]['system_misuse_status']: num_misuse += 1
    if df.iloc[i]['students_doing_well_status']: num_doing_well += 1
    print('helped: ', df.iloc[i]['helpedTransaction'], '| misuse: ', df.iloc[i]['system_misuse_status'], '| doing well: ', df.iloc[i]['students_doing_well_status'])
for i in helped_transaction_is_true:
  getWindow(i, 10)
  print(num_helped, )